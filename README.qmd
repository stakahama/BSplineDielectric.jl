---
title: "BSplineDielectric.jl"
format: gfm
execute:
  output: false
engine: julia
---

[![Build Status](https://github.com/stakahama/BSplineDielectric.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/stakahama/BSplineDielectric.jl/actions/workflows/CI.yml?query=branch%3Amain)

This package implements recursive B-splines that model imaginary and real dielectric functions as described by Johs and Hale (doi:[10.1002/pssa.200777754](https://doi.org/10.1002/pssa.200777754), 2008). They can be used more generally to represent any function that fulfills the Kramers-Kronig relation - such as the complex refractive index and Clausius-Mossotti factor.

To model dielectric functions with B-splines:

- B-splines for the imaginary part follow de Boor's recursive relation. 
- B-splines for the real part follow a separate recursive relation that fulfills the Kramers Kronig relation. 
- The modeled dielectric function should decay to zero beyond the domain of the provided data. This property can be implemented with exterior knots placed outside of the domain of data, or augmented with a separate function.

Faster implementations for the de Boor relations can be found in other packages. Knots and coefficients obtained with these packages can be used together with the model dielectric function (`MDF`) struct generated from `eps1basis` to generate the B-Spline basis for the real dielectric function.

## Installation

```julia
using Pkg
Pkg.add(url="https://github.com/stakahama/BSplineDielectric.jl")
```

## Example usage

### Preamble

```{julia}
#| echo: false
using Pkg
Pkg.activate(".")
```

```{julia}
using Plots
using BSplineDielectric
using SparseArrays
```
SparseArrays is not a requirement for BSplineDielectric, but can be installed separately to take advantage of sparse matrix operations.

### Triangular function

Define `x` values and generate curve; create function for defining knot positions from `x`.
```{julia}
function triangle(x)
    2 < x ≤ 3 ? x - 2 :
    3 < x ≤ 4 ? 4 - x :
    0
end

x = collect(range(0, 6, length=101))
curve = triangle.(x)
```

Identify knot positions and generate spline bases.
```{julia}
k = 1
t = knotgen(Clamped(), k, x[1:2:end])
B = eps2basis(k, t)
ϕ = eps1basis(k, t)
```

View first terms of spline basis.
```{julia}
#| output: true
pl = plot(layout=(2, 1), legend=false, size=(400, 500))
plot!(pl[1], x, B(1:5, x), ylabel="B(x)")
plot!(pl[2], x, ϕ(1:5, x), ylabel="ϕ(x)")
```
We can see that the basis matrix (design matrix) for `B` will be sparse but not for `ϕ`.

Get number of knots (maximum allowable index).
```{julia}
nknots(B)  # same with nknots(ϕ)
```

Get knot positions.
```{julia}
#| eval: false
knotvec(B)  # same with knotpos(ϕ)
```

Get full basis matrices evaluated at `x`.
```{julia}
Bmat = B(x) |> sparse
ϕmat = ϕ(x)
```

Estimate spline coefficients.
```{julia}
coef =  Bmat \ curve
```

Plot fits.
```{julia}
#| output: true
plot(x, curve, label="ε₂")
plot!(x, Bmat * coef, label="ε₂ model")
plot!(x, ϕmat * coef, label="ε₁ model")
plot!(size=(400, 250))
```

### Lorentzian line shape function 

The Lorentzian function is peak-height normalized.
```{julia}
x₀ = 1000
Γ = 20
L(x) = 1 / (1 + ((x - x₀) / (Γ / 2))^2)
```

Define domain that encompasses 99% of the Lorentzian peak area.
```{julia}
perc = 99.
bounds = Γ / 2 * tan(π / 2 * perc / 1e2)
x = range((@. x₀ + [-1, 1] * bounds)..., length = 10^3)
curve = L.(x)
```

Generate design matrices.
```{julia}
k = 3
t = knotgen(Clamped(), k, x[1:2:end])
B3 = eps2basis(k, t)
ϕ3 = eps1basis(k, t)
B3mat = B3(x) |> sparse
ϕ3mat = ϕ3(x)
```

Fit.
```{julia}
coef = B3mat \ curve
```

Plot.
```{julia}
#| output: true
plot(x, curve, label="ε₂")
plot!(x, B3mat * coef, label="ε₂ model")
plot!(x, ϕ3mat * coef, label="ε₁ model")
plot!(size=(400, 250))
```

### External knot placement

Johs and Hale suggest placement of knots outside of the range of data as one strategy to taper curves toward zero.

In the following example, the wings of the Lorentzian function are truncated to contain only 80% of the peak area, and B-spline coefficients are fitted to this data only. Then, we use these spline coefficients to extrapolate over the range of `x` that contains 95% of the peak area. Two knot placements are compared:

1. clamped ("Clamped")
2. extended ("PaddedLinear")

Define functions for generating `x` values and curves.
```{julia}
xvals = let x₀=x₀, Γ=Γ, N=10^3
  # generate x values for a Lorentzian function with fixed parameters using N points
  function (perc)
    bounds = Γ / 2 * tan(π / 2 * perc / 1e2)
    return range((@. x₀ + [-1, 1] * bounds)..., length=N)
  end
end

function testf(k, t, x, xp)
  # fit curve over x
  # predict curve over xp
  B = eps2basis(k, t)
  ϕ = eps1basis(k, t)
  c = sparse(B(x)) \ L.(x)
  return hcat(ϕ(xp) * c, sparse(B(xp)) * c)
end
```

Apply functions. The exansion factor is arbitrarily selected in this case to generate a close match.
```{julia}
# x values
x80 = xvals(80.)
x95 = xvals(95.)

# parameters
k = 3                 # degree
breaks = x80[1:2:end] # break points (interior knots)
expf = 1.5e2          # expansion factor

# knots
t_clamp = knotgen(Clamped(), k, breaks)
t_ext = knotgen(PaddedLinear(), k, breaks, expf)

# extrapolated curves
clamped = testf(k, t_clamp, x80, x95)
extended = testf(k, t_ext, x80, x95)
```

Compare knot placement.
```{julia}
#| output: true
xrg = extrema(x95) 
pl = plot(layout=(2, 1), size=(400, 500))
plot!(pl[1], x95, L.(x95), label=false, xlim=xrg)
addjitter(x, s=0.005) = x .+ s .* randn(length(x))
scatter!(pl[2], vcat(t_clamp, t_ext),
    vcat(fill(2, length(t_clamp)), fill(1, length(t_ext))) |>
    addjitter,
    xlim=xrg,
    yticks=([1, 2], ["extended" "clamped"]), ylim=(0, 4),
    legend=false)
```

Placement of knots beyond range of provided data (spanning 80% of Lorentzian peak area) enables better extrapolation of peak wings and estimation of `ε₁`.
```{julia}
#| output: true
cs = palette(:tab10)
pl = plot(layout=(2, 1), size=(400, 500))
plot!(pl[1], x80, L.(x80), linecolor=cs[1], label="ε₂ (80%)", legend=:topleft)
plot!(pl[1], x95, hcat(clamped[:,2], extended[:,2]), 
    linestyle=[:solid :dash], linecolor=cs[2:3]',
    label=["ε₂ clamped" "ε₂ extended"])
plot!(pl[2], x95, hcat(clamped[:,1], extended[:,1]), 
    linestyle=[:solid :dash], linecolor=cs[2:3]',
    label=["ε₁ clamped" "ε₁ extended"], legend=:inside)
hline!(pl[2], [0.0], linestyle=:dot, linecolor=cs[8], label=nothing)
```

Close-up view of extended knot placement. The extended knots do not extrapolate the wings perfectly, but provide an improvement over the conventional clamped placement.
```{julia}
#| output: true
pl = plot(size=(400, 250))
plot!(pl, x95, L.(x95), linecolor=cs[1], label="ε₂ (95%)")
plot!(pl, x95, extended, linestyle=[:solid :dash], 
    label=["ε₁ extended" "ε₂ extended"])
hline!(pl, [0.0], linestyle=:dot, label=nothing)
```

## Notes

Standard B-splines are used to model the imaginary part while another recursive formula models the real part. The former are more efficiently implemented in several other packages:

- [BSplineKit.jl](https://github.com/jipolanco/BSplineKit.jl)
- [BasicBSpline.jl](https://github.com/hyrodium/BasicBSpline.jl)
- [BSplines.jl](https://github.com/sostock/BSplines.jl)
- [Dierckx.jl](https://github.com/JuliaMath/Dierckx.jl)

and the coefficients can be used together with the complementary splines (from `ep1basis`) generated by this package.

## References

- Johs, B. and Hale, J. S.: Dielectric function representation by B-splines, physica status solidi (a), 205, 715–719, https://doi.org/10.1002/pssa.200777754, 2008.
- de Boor, C.: /A Practical Guide to Splines: Revised Edition/, Springer-Verlag, New York, 2003.
